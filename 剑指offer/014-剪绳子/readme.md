# 014-剪绳子

tags： 动态规划 贪婪算法

---

## 题目原文

[牛客网暂未收录]()

题目：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n>1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。

## 解题思路

#### 动态规划

> [参考](https://blog.csdn.net/upupday19/article/details/79315885)

需要O(n^2)时间和O(n)空间

设f(n)代表长度为n的绳子剪成若干段的最大乘积，如果第一刀下去，第一段长度是i，那么剩下的就需要剪n-i，那么f(n)=max{f(i)f(n-i)}。而f(n)的最优解对应着f(i)和f(n-i)的最优解，假如f(i)不是最优解，那么其最优解和f(n-i)乘积肯定大于f(n)的最优解，和f(n)达到最优解矛盾，所以f(n)的最优解对应着f(i)和f(n-i)的最优解。首先，剪绳子是最优解问题，其次，大问题包含小问题，并且大问题的最优解包含着小问题的最优解，所以可以使用动态规划求解问题，并且从小到大求解，把小问题的最优解记录在数组中，求大问题最优解时就可以直接获取，避免重复计算

n<2时，由于每次至少减一次，所以返回0。n=2时，只能剪成两个1，那么返回1。n=3时，可以剪成3个1，或者1和2，那么最大乘积是2。当n>3时，就可以使用公式进行求解。

f(4)=max{f(1)f(3), f(2)f(2)}
f(5)=max{f(1)f(4), f(2)f(3)}
...
f(n)=max{f(1)f(n-1), f(2)f(n-2), f(3)f(n-3), ..., f(i)(fn-i), ...}

因为需要保证f(i)f(n-i)不重复，就需要保证i<=n/2，这是一个限制条件，求1～n/2范围内的乘积，得到最大值


#### 贪婪算法

只需要O(1)时间和空间

n<2时，返回0；n=2时，返回1；n=3时，返回2

根据数学计算，当n>=5时，2(n-2)>n，3(n-3)>n，这就是说，将绳子剪成2和(n-2)或者剪成3和(n-3)时，乘积大于不剪的乘积，因此需要把绳子剪成2或者3。并且3(n-3)>=2(n-2)，也就是说，当n>=5时，应该剪尽量多的3，可以使最后的乘积最大。对于长度是n的绳子，我们可以剪出n/3个3，剩余长度是1或者2，如果余数是1，就可以把1和最后一个3合并成4，那么4剪出两个2得到的乘积是4，比1*3大，因此这种情况下，需要将3的个数减少1，变成两个2；如果余数是2，那么无需做修改

可以得到最大的乘积是：3^timesOf3 * 2^timesOf2

相比动态规划，计算更简便，但是需要一定的数学技巧。

**至于为什么不可以用4(n-4)>n, 5(n-5)>n, 6(n-6)>n**. 我的想法是: 上面推导得到

- 尽量减3的乘积大于尽量减2的乘积
- 当n>=5时, 绳子剪成2和(n-2)或者剪成3和(n-3)时，乘积大于不剪的乘积

那么如果绳子被划为abcd四段, 只要abcd中有长度大于5的, 那么就可以继续按3或按2拆分, 得到比之前更大的结果.

那么按4拆分可以么, 可以发现按4拆分, 等效于按2拆分, 没有3^timesOf3 * 2^timesOf2的乘积大

那么按5拆分呢, 可以发现等效于按2拆分和按3拆分的数量一半一半, 但还没有3^timesOf3 * 2^timesOf2的乘积大

那么按6拆分呢, 可以发现把6拆分为3*3乘积比6大, 所以先按3后按2拆分的策略最好.

### 注意

动态规划的c++代码中, products保存的是子问题的最优解, 所以products[3] = 3, 而不是2

贪婪算法的c++代码中, pow的返回值是double类型, 需要强制转换为int类型

## 代码

### [c++代码](./src/cpp/014-剪绳子.cpp)

```c++
// ====================动态规划====================
int maxProductAfterCutting_solution1(int length)
{
	if (length < 2)
		return 0;
	if (length == 2)
		return 1;
	if (length == 3)
		return 2;

	int* products = new int[length + 1];
	products[0] = 0;
	products[1] = 1;
	products[2] = 2;
	products[3] = 3;

	int max = 0;
	for (int i = 4; i <= length; ++i)
	{
		max = 0;
		for (int j = 1; j <= i / 2; ++j)
		{
			int product = products[j] * products[i - j];
			if (max < product)
				max = product;

			products[i] = max;
		}
	}

	max = products[length];
	delete[] products;

	return max;
}

// ====================贪婪算法====================
int maxProductAfterCutting_solution2(int length)
{
	if (length < 2)
		return 0;
	if (length == 2)
		return 1;
	if (length == 3)
		return 2;

	// 尽可能多地减去长度为3的绳子段
	int timesOf3 = length / 3;

	// 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。
	// 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 > 3*1。
	if (length - timesOf3 * 3 == 1)
		timesOf3 -= 1;

	int timesOf2 = (length - timesOf3 * 3) / 2;

	return (int)(pow(3, timesOf3)) * (int)(pow(2, timesOf2));
}
```

### [python代码](./src/python/014-剪绳子.py)

```python

```

### 拓展 切杆问题

#### 问题描述

切割杆，现有长度为n的杆，价值数组是prices[]，数组长度是n，已知长度i对应的价值是prices[i-1]，比如长度1对应的价值数是prices[0]。将其切割，求碎片的最大价值。

#### 思路

 假设第一刀切下来是i，那么剩下的是n-i，假设f(n)代表切割n所能获得的最大价值，那么f(n)=max{f(i)+f(n-i)}，因此大问题可以分解成小问题，并且同剪绳子问题，大问题的最优解包括小问题的最优解，那么可以求出小问题的最优解，存到数组中，在求大问题最优解时就可以直接从数组中获取，最终获得最优解。
 f(0)=0
 f(1)=prices[0]
 f(2)=max{prices[1], f(1)+f(1)}
 f(3)=max{prices[2], f(1)+f(2)}
 f(4)=max{prices[3], f(1)+f(3), f(2)+f(2)}
 ...
 f(n)=max{prices[n-1], f(1)+f(n-1), f(2)+f(n-2), ..., f(i)+f(n-i), ...}

对于f(n)，为了保证f(i)+f(n-i)不重复，需要保证i<=n/2，这也是循环次数限制条件，在1～n/2范围内求解。